#!/bin/bash

PRIVATE_CONFDIR="<%= @private_confdir %>"
PUBLIC_CONFDIR="<%= @public_confdir %>"
DEPLOYMENT_KEY="<%= @deployment_private_key_loc %>"
PUBLIC_REPO_URL="<%= @public_repo_url %>"
PRIVATE_REPO_URL="<%= @private_repo_url %>"
GIT_BRANCH="<%= @git_branch %>"
myname=`basename "$0"`

# pipefail is useful
set -o pipefail

info() {
  # This allows us to use this bash function as a pipe destination which makes
  # logging slightly easier
  read INPUT
  /usr/bin/logger --id --priority local3.info --tag ${myname} "INFO: $INPUT"
}

error() {
  /usr/bin/logger --id --stderr --priority local3.err --tag ${myname} "ERROR: $@"
  exit 1
}

git_clone_update() {
  local localdir="$1"
  local remoterepo="$2"

  # Note: If ‘|&’ is used, the standard error of command1 is connected to
  # command2’s standard input through the pipe; it is shorthand for 2>&1 |.
  # This implicit redirection of the standard error is performed after any
  # redirections specified by the command.
  # Source: http://www.gnu.org/software/bash/manual/bash.html#Pipelines

  # Assumption: the .git directory does not exist, so most likely hasn't been
  # cloned as yet
  if [ ! -e "${localdir}/.git" ]; then
    /usr/bin/git clone \
      "${remoterepo}" \
      "${localdir}" \
      |& info

    # What we really care about here is the return status of the first command.
    # Note that PIPESTATUS[0] stores the exit code of the first command in the
    # (piped) chain since we 'set -o pipefail' earlier.
    retval=${PIPESTATUS[0]}

    if [ $retval != 0 ]; then
      return $retval
    fi
  fi

  cd "${localdir}" \
    && /usr/bin/git fetch --all \
    && /usr/bin/git reset --hard "origin/${GIT_BRANCH}" \
    && /usr/bin/git checkout --force "${GIT_BRANCH}" \
    && /usr/bin/git submodule sync \
    && /usr/bin/git submodule update --recursive \
    |& info

  retval=${PIPESTATUS[0]}
  return $retval
}


# Need to be root
if [ `id -u -n` != "root" ]; then
  error "Must run as root, not" `id -u -n`
fi

LOCKFILE=/tmp/puppulllock.txt
if [ -e ${LOCKFILE} ] && kill -0 `cat ${LOCKFILE}`; then
  error "puppull is already running"
fi

# make sure the lockfile is removed when we exit and then claim it
trap "rm -f ${LOCKFILE}; exit" INT TERM EXIT

# echo our PID into the lockfile
echo $$ > ${LOCKFILE}

# Needed in order to specify a private key
export GIT_SSH='<%= @git_puppet_ssh_wrapper_loc %>'

# Clone/update the private puppet repo
git_clone_update "${PRIVATE_CONFDIR}" "${PRIVATE_REPO_URL}"
if [ $? != 0 ]; then
  error "Something went wrong when running command: git_clone_update ${PRIVATE_CONFDIR} ${PRIVATE_REPO_URL}"
fi

# Clone/update the public puppet repo
git_clone_update "${PUBLIC_CONFDIR}" "${PUBLIC_REPO_URL}"
if [ $? != 0 ]; then
  error "Something went wrong when running command: git_clone_update ${PUBLIC_CONFDIR} ${PUBLIC_REPO_URL}"
fi

# Clean out the lockfile
rm -f ${LOCKFILE}

